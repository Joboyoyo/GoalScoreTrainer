<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VEX Goal Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .action-button { transition: all 0.1s ease-in-out; }
        .action-button:active { transform: scale(0.95); }
        .goal-bar-container {
            background-color: #e2e8f0;
            border-radius: 0.375rem;
            padding: 0.5rem;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.05);
            display: flex;
            justify-content: center;
        }
        .goal-bar {
            display: flex;
            height: 3rem;
            border-radius: 0.25rem;
            overflow: hidden;
            gap: 2px;
        }
        .goal-slot {
            height: 3rem;
            flex: 1;
        }
        .blocks-red, .slot-red { background-color: #ef4444; }
        .blocks-blue, .slot-blue { background-color: #3b82f6; }
        .blocks-empty, .slot-empty { background-color: #cbd5e1; }
        .control-zone {
            border-top: 3px dashed #4b5563;
            border-bottom: 3px dashed #4b5563;
        }
        #historyModal, #timerResultOverlay, #countdownOverlay { transition: opacity 0.3s ease-in-out; }
        .mode-toggle button.active {
            background-color: #4f46e5;
            color: white;
        }
    </style>
</head>
<body class="text-slate-800 min-h-screen antialiased flex flex-col items-center justify-center p-4">

    <!-- Timer Display Bar (Outside Main Container) -->
    <div id="timerBar" class="w-full max-w-lg mx-auto bg-slate-800 text-white flex items-center justify-between px-4 py-2 rounded-t-lg mb-2" style="display: none;">
        <div class="text-lg font-bold">Time: <span id="timerDisplay">30</span></div>
        <div class="text-lg font-bold">Correct: <span id="timerScore">0</span></div>
    </div>

    <div class="w-full max-w-lg mx-auto">
        <div class="bg-white shadow-xl rounded-lg p-6 relative">
            <!-- Overlays -->
            <div id="countdownOverlay" class="absolute inset-0 bg-white bg-opacity-95 flex items-center justify-center rounded-lg z-30" style="display: none;">
                <div id="countdownDisplay" class="text-8xl font-bold text-slate-700">3</div>
            </div>
            <div id="timerResultOverlay" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg opacity-0 pointer-events-none z-20" style="display: none;">
                <div class="bg-white text-slate-800 p-6 rounded-lg shadow-2xl text-center relative max-w-sm">
                    <button id="closeTimerResultBtn" class="action-button absolute top-2 right-2 text-slate-400 hover:text-slate-600 p-2">
                        <i class="fas fa-times fa-lg"></i>
                    </button>
                    <div class="text-2xl font-bold">Time's Up!</div>
                    <div class="mt-2 text-4xl">You got <span id="finalTimerScore" class="font-bold text-green-500">0</span> correct!</div>
                    <div class="mt-4 pt-4 border-t w-full">
                        <h4 class="text-sm font-bold text-slate-600 mb-2">Session Stats</h4>
                        <div id="analysisResults" class="text-lg text-slate-500 text-center">
                            <!-- Analysis will be injected here -->
                        </div>
                    </div>
                    <div class="flex justify-center mt-4">
                        <button id="playAgainBtn" class="action-button bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg">Play Again</button>
                    </div>
                </div>
            </div>
            <div id="historyModal" class="absolute inset-0 bg-white p-6 rounded-lg z-40 overflow-y-auto" style="display: none;">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-slate-800">Performance History</h2>
                    <button id="closeHistoryBtn" class="action-button text-slate-500 hover:text-slate-800 p-2">
                        <i class="fas fa-times fa-2x"></i>
                    </button>
                </div>
                <div class="mb-4">
                    <canvas id="historyChart"></canvas>
                </div>
                <div id="historyContainer" class="space-y-4"></div>
            </div>

            <header class="text-center mb-4">
                <div class="mode-toggle mb-2 flex justify-center bg-slate-200 rounded-lg p-1">
                    <button id="upperModeBtn" class="flex-1 py-1 px-3 text-sm font-semibold rounded-md">Upper Goal</button>
                    <button id="lowerModeBtn" class="flex-1 py-1 px-3 text-sm font-semibold rounded-md">Lower Goal</button>
                    <button id="longModeBtn" class="flex-1 py-1 px-3 text-sm font-semibold rounded-md">Long Goal</button>
                </div>
                <h1 id="mainTitle" class="text-2xl font-bold text-slate-900">Goal Trainer</h1>
                <p class="text-sm text-slate-500 mt-1">Estimate the point difference for this goal.</p>
            </header>

            <div id="mainContent">
                <div class="mb-4">
                    <div class="goal-bar-container">
                        <div id="goalBar" class="goal-bar"></div>
                    </div>
                </div>
                <div class="mb-4">
                    <label for="guessInput" class="block text-center font-medium text-slate-700 mb-2">Enter Lead (+Blue / -Red)</label>
                    <input type="number" id="guessInput" placeholder="e.g., -12 for Red lead" class="w-full text-center text-lg p-2 border-2 border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="newScenarioBtn" class="action-button w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 rounded-lg">New Scenario</button>
                    <button id="submitBtn" class="action-button w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg">Submit Guess</button>
                </div>
                <button id="startTimerBtn" class="action-button w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg mt-3">
                    <i class="fas fa-stopwatch"></i> Start 30s Timer Mode
                </button>
                <div id="resultSection" class="mt-4 pt-4 border-t border-slate-200 text-center hidden">
                    <div id="feedback" class="text-xl font-bold mb-2"></div>
                    <div class="text-sm text-slate-600">
                        <p>Correct Answer: <span id="correctAnswer" class="font-bold"></span></p>
                        <p id="scoreBreakdown" class="mt-1"></p>
                    </div>
                </div>
                <div id="statsSection" class="mt-4 pt-4 border-t border-slate-200 hidden">
                    <h3 class="text-center font-bold text-slate-700 mb-2">Today's Statistics (<span id="statsModeTitle"></span>)</h3>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm text-slate-600">
                        <span class="font-medium">Attempts:</span><span id="statsAttempts" class="text-right font-mono">0</span>
                        <span class="font-medium">Correct:</span><span id="statsCorrect" class="text-right font-mono">0</span>
                        <span class="font-medium">Accuracy:</span><span id="statsAccuracy" class="text-right font-mono">0%</span>
                        <span class="font-medium">Avg. Error:</span><span id="statsAvgError" class="text-right font-mono">0.0</span>
                        <span class="font-medium">Avg. Time (fast):</span><span id="statsAvgTime" class="text-right font-mono">0.0s</span>
                    </div>
                    <div class="mt-3 pt-2 border-t border-slate-100">
                        <canvas id="statsChart"></canvas>
                    </div>
                    <div class="flex gap-2 mt-3">
                        <button id="historyBtn" class="action-button text-xs bg-slate-200 text-slate-700 hover:bg-slate-300 w-full flex items-center justify-center gap-1 py-2 rounded-md">
                            <i class="fas fa-history"></i> View History
                        </button>
                        <button id="resetStatsBtn" class="action-button text-xs text-slate-500 hover:text-red-600 w-full flex items-center justify-center gap-1 py-2 rounded-md">
                            <i class="fas fa-trash-alt"></i> Reset All Stats
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const BLOCK_POINTS = 3;
        const GOAL_SETTINGS = {
            upper: { capacity: 7, controlBonus: 8, isLong: false, name: 'Upper Goal' },
            lower: { capacity: 7, controlBonus: 6, isLong: false, name: 'Lower Goal' },
            long: { capacity: 15, controlBonus: 10, isLong: true, czStart: 6, czEnd: 8, name: 'Long Goal' }
        };

        let currentBlocks = [];
        let currentRedBlocks = 0, currentBlueBlocks = 0;
        let isTimerMode = false, timerInterval, timerScore = 0, timerHistory = [];
        let scenarioStartTime = 0, statsChart = null, historyChart = null, currentMode = 'upper';
        let dailyStats = {};

        const elements = {
            goalBar: document.getElementById('goalBar'),
            guessInput: document.getElementById('guessInput'),
            newScenarioBtn: document.getElementById('newScenarioBtn'),
            submitBtn: document.getElementById('submitBtn'),
            startTimerBtn: document.getElementById('startTimerBtn'),
            resultSection: document.getElementById('resultSection'),
            feedbackEl: document.getElementById('feedback'),
            correctAnswerEl: document.getElementById('correctAnswer'),
            scoreBreakdownEl: document.getElementById('scoreBreakdown'),
            statsSection: document.getElementById('statsSection'),
            statsModeTitle: document.getElementById('statsModeTitle'),
            statsAttempts: document.getElementById('statsAttempts'),
            statsCorrect: document.getElementById('statsCorrect'),
            statsAccuracy: document.getElementById('statsAccuracy'),
            statsAvgError: document.getElementById('statsAvgError'),
            statsAvgTime: document.getElementById('statsAvgTime'),
            resetStatsBtn: document.getElementById('resetStatsBtn'),
            timerBar: document.getElementById('timerBar'),
            timerDisplay: document.getElementById('timerDisplay'),
            timerScoreEl: document.getElementById('timerScore'),
            timerResultOverlay: document.getElementById('timerResultOverlay'),
            finalTimerScore: document.getElementById('finalTimerScore'),
            playAgainBtn: document.getElementById('playAgainBtn'),
            closeTimerResultBtn: document.getElementById('closeTimerResultBtn'),
            mainContent: document.getElementById('mainContent'),
            countdownOverlay: document.getElementById('countdownOverlay'),
            countdownDisplay: document.getElementById('countdownDisplay'),
            analysisResultsEl: document.getElementById('analysisResults'),
            upperModeBtn: document.getElementById('upperModeBtn'),
            lowerModeBtn: document.getElementById('lowerModeBtn'),
            longModeBtn: document.getElementById('longModeBtn'),
            mainTitle: document.getElementById('mainTitle'),
            historyBtn: document.getElementById('historyBtn'),
            historyModal: document.getElementById('historyModal'),
            closeHistoryBtn: document.getElementById('closeHistoryBtn'),
            historyContainer: document.getElementById('historyContainer')
        };

        function createEmptyStatsObject() {
            return { attempts: 0, correct: 0, totalError: 0, solveTimes: [], analysis: { byTotal: {} } };
        }

        function getTodayKey() {
            return new Date().toISOString().split('T')[0];
        }

        function loadStats() {
            const savedStats = localStorage.getItem('goalTrainerDailyStats');
            dailyStats = savedStats ? JSON.parse(savedStats) : {};
            const todayKey = getTodayKey();
            if (!dailyStats[todayKey]) {
                dailyStats[todayKey] = {
                    upper: createEmptyStatsObject(),
                    lower: createEmptyStatsObject(),
                    long: createEmptyStatsObject()
                };
            }
            updateStatsDisplay();
        }

        function saveStats() {
            localStorage.setItem('goalTrainerDailyStats', JSON.stringify(dailyStats));
        }
        
        function updateStatsDisplay() {
            const todayKey = getTodayKey();
            const currentStats = dailyStats[todayKey][currentMode];
            elements.statsModeTitle.textContent = GOAL_SETTINGS[currentMode].name;
            elements.statsAttempts.textContent = currentStats.attempts;
            elements.statsCorrect.textContent = currentStats.correct;
            const accuracy = currentStats.attempts > 0 ? ((currentStats.correct / currentStats.attempts) * 100).toFixed(1) : 0;
            elements.statsAccuracy.textContent = `${accuracy}%`;
            const avgError = currentStats.attempts > 0 ? (currentStats.totalError / currentStats.attempts).toFixed(1) : 0;
            elements.statsAvgError.textContent = avgError;
            const validTimes = currentStats.solveTimes.filter(t => t <= 10000);
            const avgTime = validTimes.length > 0 ? (validTimes.reduce((a, b) => a + b, 0) / validTimes.length / 1000).toFixed(1) : 0;
            elements.statsAvgTime.textContent = `${avgTime}s`;

            if (currentStats.attempts > 0) {
                renderStatsChart();
                elements.statsSection.classList.remove('hidden');
            } else {
                elements.statsSection.classList.add('hidden');
            }
        }

        function generateScenario() {
            const { capacity, isLong } = GOAL_SETTINGS[currentMode];
            const r1 = Math.floor(Math.random() * (capacity + 1));
            const r2 = Math.floor(Math.random() * (capacity + 1));
            const totalBlocks = Math.max(r1, r2);
            currentRedBlocks = Math.floor(Math.random() * (totalBlocks + 1));
            currentBlueBlocks = totalBlocks - currentRedBlocks;
            if (isLong) {
                currentBlocks = Array(capacity).fill('empty');
                const emptySlots = capacity - totalBlocks;
                const leftGap = Math.floor(Math.random() * (emptySlots + 1));
                const middleGap = Math.floor(Math.random() * (emptySlots - leftGap + 1));
                let currentIndex = leftGap;
                for(let i=0; i < currentBlueBlocks; i++) currentBlocks[currentIndex++] = 'blue';
                currentIndex += middleGap;
                for(let i=0; i < currentRedBlocks; i++) currentBlocks[currentIndex++] = 'red';
            }
            renderGoal();
            resetUI();
            scenarioStartTime = Date.now();
        }

        function renderGoal() {
            elements.goalBar.innerHTML = '';
            const { capacity, isLong, czStart, czEnd } = GOAL_SETTINGS[currentMode];
            if (isLong) {
                elements.goalBar.style.gap = '2px';
                elements.goalBar.style.width = '100%';
                currentBlocks.forEach((slot, index) => {
                    const slotDiv = document.createElement('div');
                    slotDiv.className = `goal-slot slot-${slot}`;
                    if (index >= czStart && index <= czEnd) slotDiv.classList.add('control-zone');
                    elements.goalBar.appendChild(slotDiv);
                });
            } else {
                elements.goalBar.style.gap = '0px';
                elements.goalBar.style.width = '60%';
                const redWidth = (currentRedBlocks / capacity) * 100;
                const blueWidth = (currentBlueBlocks / capacity) * 100;
                const emptyWidth = ((capacity - currentRedBlocks - currentBlueBlocks) / capacity) * 100;
                if (blueWidth > 0) elements.goalBar.innerHTML += `<div class="blocks-blue" style="width: ${blueWidth}%;"></div>`;
                if (emptyWidth > 0) elements.goalBar.innerHTML += `<div class="blocks-empty" style="width: ${emptyWidth}%;"></div>`;
                if (redWidth > 0) elements.goalBar.innerHTML += `<div class="blocks-red" style="width: ${redWidth}%;"></div>`;
            }
        }
        
        function resetUI() {
            elements.resultSection.classList.add('hidden');
            elements.guessInput.value = '';
            elements.guessInput.disabled = false;
            elements.guessInput.focus();
        }

        function calculateDifference() {
            const { controlBonus, isLong, czStart, czEnd } = GOAL_SETTINGS[currentMode];
            let redScore = 0, blueScore = 0;
            let redBlockCount = 0, blueBlockCount = 0;
            if (isLong) {
                redBlockCount = currentBlocks.filter(s => s === 'red').length;
                blueBlockCount = currentBlocks.filter(s => s === 'blue').length;
            } else {
                redBlockCount = currentRedBlocks;
                blueBlockCount = currentBlueBlocks;
            }
            redScore = redBlockCount * BLOCK_POINTS;
            blueScore = blueBlockCount * BLOCK_POINTS;
            let redInCz = 0, blueInCz = 0;
            if (isLong) {
                for (let i = czStart; i <= czEnd; i++) {
                    if (currentBlocks[i] === 'red') redInCz++;
                    if (currentBlocks[i] === 'blue') blueInCz++;
                }
            } else {
                redInCz = redBlockCount;
                blueInCz = blueBlockCount;
            }
            if (redInCz > blueInCz) redScore += controlBonus;
            else if (blueInCz > redInCz) blueScore += controlBonus;
            return { redScore, blueScore, difference: redScore - blueScore, redBlockCount, blueBlockCount };
        }

        function updateStatsWithNewData(statsObject, data) {
            statsObject.attempts++;
            statsObject.totalError += data.error;
            if (data.error === 0) statsObject.correct++;
            if (data.solveTime) statsObject.solveTimes.push(data.solveTime);
            
            const totalBlocksKey = data.totalBlocks.toString();
            if (!statsObject.analysis.byTotal[totalBlocksKey]) statsObject.analysis.byTotal[totalBlocksKey] = { count: 0, solveTimes: [] };
            statsObject.analysis.byTotal[totalBlocksKey].count++;
            if (data.solveTime) statsObject.analysis.byTotal[totalBlocksKey].solveTimes.push(data.solveTime);
        }

        function handleSubmit() {
            if (elements.resultSection.classList.contains('hidden') && !isTimerMode) {
                const solveTime = Date.now() - scenarioStartTime;
                const userGuess = parseInt(elements.guessInput.value, 10) || 0;
                const { redScore, blueScore, difference, redBlockCount, blueBlockCount } = calculateDifference();
                const correctGuessValue = -difference;
                const error = Math.abs(userGuess - correctGuessValue);

                updateStatsWithNewData(dailyStats[getTodayKey()][currentMode], {
                    error: error,
                    solveTime: solveTime,
                    totalBlocks: redBlockCount + blueBlockCount
                });
                
                let correctString = '';
                if (difference === 0) correctString = 'Tie';
                else if (difference > 0) correctString = `Red by ${difference}`;
                else correctString = `Blue by ${Math.abs(difference)}`;
                elements.correctAnswerEl.textContent = correctString;
                const controlBonus = GOAL_SETTINGS[currentMode].controlBonus;
                const redBonusText = (redScore > redBlockCount * BLOCK_POINTS) ? `+${controlBonus}` : '';
                const blueBonusText = (blueScore > blueBlockCount * BLOCK_POINTS) ? `+${controlBonus}` : '';
                elements.scoreBreakdownEl.innerHTML = `
                    <span class="text-red-600">R: ${redBlockCount*BLOCK_POINTS} ${redBonusText} = <strong>${redScore}</strong></span> | 
                    <span class="text-blue-600">B: ${blueBlockCount*BLOCK_POINTS} ${blueBonusText} = <strong>${blueScore}</strong></span>
                `;
                
                if (error === 0) {
                    elements.feedbackEl.textContent = 'ðŸŽ¯ Perfect!';
                    elements.feedbackEl.className = 'text-xl font-bold mb-2 text-green-600';
                } else {
                    elements.feedbackEl.textContent = 'ðŸ¤” Not Quite!';
                    elements.feedbackEl.className = 'text-xl font-bold mb-2 text-amber-600';
                }
                
                saveStats();
                updateStatsDisplay();
                elements.resultSection.classList.remove('hidden');
                elements.guessInput.disabled = true;
            }
        }
        
        function startTimerMode() {
            isTimerMode = true;
            timerScore = 0;
            timerHistory = [];
            let countdown = 3;
            elements.countdownDisplay.textContent = countdown;
            elements.countdownOverlay.style.display = 'flex';
            elements.mainContent.querySelectorAll('button').forEach(b => b.disabled = true);
            elements.guessInput.disabled = true;

            const countdownInterval = setInterval(() => {
                countdown--;
                elements.countdownDisplay.textContent = countdown > 0 ? countdown : 'Go!';
                if (countdown < 0) {
                    clearInterval(countdownInterval);
                    elements.countdownOverlay.style.display = 'none';
                    beginTimedChallenge();
                }
            }, 1000);
        }

        function beginTimedChallenge() {
            let timeLeft = 30;
            elements.timerDisplay.textContent = timeLeft;
            elements.timerScoreEl.textContent = timerScore;
            elements.timerBar.style.display = 'flex';
            
            elements.timerResultOverlay.style.display = 'none';
            elements.timerResultOverlay.classList.add('opacity-0', 'pointer-events-none');
            generateScenario();

            timerInterval = setInterval(() => {
                timeLeft--;
                elements.timerDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    endTimerMode();
                }
            }, 1000);
        }

        function endTimerMode() {
            clearInterval(timerInterval);
            isTimerMode = false;
            elements.guessInput.disabled = true;
            
            let sessionTotalTime = 0;
            timerHistory.forEach(h => {
                sessionTotalTime += h.solveTime;
                updateStatsWithNewData(dailyStats[getTodayKey()][currentMode], h);
            });
            saveStats();
            updateStatsDisplay();
            
            const sessionAvgTime = timerHistory.length > 0 ? (sessionTotalTime / timerHistory.length / 1000).toFixed(1) : 0;
            elements.analysisResultsEl.innerHTML = `Avg. Time: <span class="font-bold text-indigo-600">${sessionAvgTime}s</span>`;

            elements.finalTimerScore.textContent = timerScore;
            elements.timerBar.style.display = 'none';
            elements.timerResultOverlay.style.display = 'flex';
            elements.timerResultOverlay.classList.remove('opacity-0', 'pointer-events-none');
        }

        function handleTimerSubmit() {
            const solveTime = Date.now() - scenarioStartTime;
            const userGuess = parseInt(elements.guessInput.value, 10) || 0;
            const { difference, redBlockCount, blueBlockCount } = calculateDifference();
            const correctGuessValue = -difference;
            const error = Math.abs(userGuess - correctGuessValue);

            timerHistory.push({
                error: error,
                solveTime: solveTime,
                totalBlocks: redBlockCount + blueBlockCount
            });

            if (error === 0) {
                timerScore++;
                elements.timerScoreEl.textContent = timerScore;
            }
            generateScenario();
        }

        function renderStatsChart() {
            const ctx = document.getElementById('statsChart').getContext('2d');
            const analysis = dailyStats[getTodayKey()][currentMode].analysis.byTotal;

            const labels = Object.keys(analysis).map(Number).sort((a,b) => a-b);
            
            const timeData = labels.map(label => {
                const key = label.toString();
                const categoryTimes = analysis[key].solveTimes || [];
                const validTimes = categoryTimes.filter(t => t <= 10000);
                if (validTimes.length === 0) return 0;
                const avgTime = validTimes.reduce((a, b) => a + b, 0) / validTimes.length;
                return (avgTime / 1000).toFixed(1);
            });

            const frequencyData = labels.map(label => {
                const key = label.toString();
                return analysis[key].count;
            });

            if (statsChart) statsChart.destroy();

            statsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels.map(l => `${l} Blocks`),
                    datasets: [
                        {
                            label: 'Average Time (s)',
                            data: timeData,
                            backgroundColor: 'rgba(129, 140, 248, 0.6)',
                            borderColor: 'rgba(129, 140, 248, 1)',
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Frequency',
                            data: frequencyData,
                            backgroundColor: 'rgba(209, 213, 219, 0.6)',
                            borderColor: 'rgba(107, 114, 128, 1)',
                            type: 'line',
                            yAxisID: 'y1',
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    scales: {
                        y: { beginAtZero: true, position: 'left', title: { display: true, text: 'Avg. Solve Time (s)' } },
                        y1: { beginAtZero: true, position: 'right', title: { display: true, text: 'Frequency' }, grid: { drawOnChartArea: false } },
                        x: { title: { display: true, text: 'Total Blocks in Goal' } }
                    },
                    plugins: { title: { display: true, text: 'Performance & Scenario Frequency' } }
                }
            });
        }
        
        function setMode(mode) {
            currentMode = mode;
            elements.upperModeBtn.classList.toggle('active', mode === 'upper');
            elements.lowerModeBtn.classList.toggle('active', mode === 'lower');
            elements.longModeBtn.classList.toggle('active', mode === 'long');
            elements.mainTitle.textContent = `${GOAL_SETTINGS[mode].name} Trainer`;
            updateStatsDisplay();
            generateScenario();
        }
        
        function renderHistory() {
            elements.historyContainer.innerHTML = '';
            const sortedDates = Object.keys(dailyStats).sort().reverse();

            if (historyChart) historyChart.destroy();
            const ctx = document.getElementById('historyChart').getContext('2d');
            
            const labels = sortedDates.map(date => new Date(date + 'T00:00:00').toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
            const upperData = [], lowerData = [], longData = [], frequencyData = [];

            sortedDates.forEach(date => {
                const day = dailyStats[date];
                let totalAttempts = 0;
                ['upper', 'lower', 'long'].forEach(mode => {
                    const modeStats = day[mode];
                    const validTimes = modeStats.solveTimes.filter(t => t <= 10000);
                    const avgTime = validTimes.length > 0 ? (validTimes.reduce((a, b) => a + b, 0) / validTimes.length / 1000) : null;
                    if (mode === 'upper') upperData.push(avgTime);
                    if (mode === 'lower') lowerData.push(avgTime);
                    if (mode === 'long') longData.push(avgTime);
                    totalAttempts += modeStats.attempts;
                });
                frequencyData.push(totalAttempts);
            });
            
            historyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels.reverse(),
                    datasets: [
                        { type: 'line', label: 'Upper Goal Avg Time', data: upperData.reverse(), borderColor: 'rgba(239, 68, 68, 1)', yAxisID: 'y', tension: 0.1, fill: false },
                        { type: 'line', label: 'Lower Goal Avg Time', data: lowerData.reverse(), borderColor: 'rgba(59, 130, 246, 1)', yAxisID: 'y', tension: 0.1, fill: false },
                        { type: 'line', label: 'Long Goal Avg Time', data: longData.reverse(), borderColor: 'rgba(245, 158, 11, 1)', yAxisID: 'y', tension: 0.1, fill: false },
                        { type: 'bar', label: 'Total Frequency', data: frequencyData.reverse(), backgroundColor: 'rgba(209, 213, 219, 0.6)', yAxisID: 'y1' }
                    ]
                },
                options: {
                    scales: {
                        y: { beginAtZero: true, position: 'left', title: { display: true, text: 'Avg. Solve Time (s)' } },
                        y1: { beginAtZero: true, position: 'right', title: { display: true, text: 'Frequency' }, grid: { drawOnChartArea: false } }
                    }
                }
            });
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (isTimerMode) handleTimerSubmit();
                else if (elements.resultSection.classList.contains('hidden')) handleSubmit();
                else generateScenario();
            }
        });

        elements.newScenarioBtn.addEventListener('click', generateScenario);
        elements.submitBtn.addEventListener('click', handleSubmit);
        elements.startTimerBtn.addEventListener('click', startTimerMode);
        elements.playAgainBtn.addEventListener('click', () => {
             elements.timerResultOverlay.style.display = 'none';
             elements.timerResultOverlay.classList.add('opacity-0', 'pointer-events-none');
             startTimerMode();
        });
        elements.closeTimerResultBtn.addEventListener('click', () => {
            elements.timerResultOverlay.style.display = 'none';
            elements.timerResultOverlay.classList.add('opacity-0', 'pointer-events-none');
            elements.mainContent.querySelectorAll('button').forEach(b => b.disabled = false);
            generateScenario();
        });
        elements.resetStatsBtn.addEventListener('click', () => {
             if (confirm("Are you sure you want to reset all stats? This cannot be undone.")) {
                dailyStats = {};
                saveStats();
                loadStats();
                updateStatsDisplay();
                if (statsChart) statsChart.destroy();
                elements.statsSection.classList.add('hidden');
            }
        });
        elements.upperModeBtn.addEventListener('click', () => setMode('upper'));
        elements.lowerModeBtn.addEventListener('click', () => setMode('lower'));
        elements.longModeBtn.addEventListener('click', () => setMode('long'));
        elements.historyBtn.addEventListener('click', () => {
            renderHistory();
            elements.historyModal.style.display = 'block';
        });
        elements.closeHistoryBtn.addEventListener('click', () => {
            elements.historyModal.style.display = 'none';
        });

        // Initial load
        loadStats();
        setMode('upper');
        generateScenario();
    </script>
</body>
</html>
